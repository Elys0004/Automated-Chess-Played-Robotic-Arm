# Robot_driver Description

This is where the vision and the brain of the "gripperone" robotic arm are. 

Vision:

We used openCV for its computer vision. In this project, we are not recognizing each of the chess pieces individually but instead, we used past memory of the chessboard and look into the difference between two frames to identify the chess movement. 

We used the binary image and thresholding to precisely figure out the movement of chess pieces. 

Chess AI algorithm:

For the Chess AI algorithm, we used alpha-beta pruning where it searches for the algorithm with the lowest number of nodes by evaluating its min and max, min for its opponent, and max for itself. 


Here are the issue and solutions that we encountered during this process:

Issue:

1. Method to send command of the Chess AI to the motor driver

Partially solved:

1. We use ROS Wrapper to wrap the Chess AI code and communicate with the motor driver. Although we couldn't try out and script the motor driver because of the "gripperone" controller issue, we have tried out to place an imaginary speed command on the robotic arm to try out whether the output could be successfully delivered from the Chess AI to the motor driver. 
	
	Here is the idea behind it, the initial speed will be zero, but once the Chess AI sends an output which is the desired chess position generated by the AI to the ROS wrapper, the Ros Wrapper will set the motor driver speed to 5 which could indicate that it is successfully transferred. Scripting of the position in the motor driver file needs to be done to request the robotic arm to move the chess. 
